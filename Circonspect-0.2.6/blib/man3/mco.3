.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "mco 3"
.TH mco 3 "2013-02-08" "perl v5.22.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\& The mco module implements a metagenome collection object.
.Ve
.SH "NOTES"
.IX Header "NOTES"
.Vb 8
\& Provides methods for the creation, manipulation, and destruction of a
\& collection of metagenomes:
\&    * new
\&    * import_metainfo
\&    * import_sequences
\&    * get_size_stats
\&    * get_rand_sample
\&    * destroy
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\& Florent Angly (florent.angly@gmail.com)
.Ve
.SS "new Title   : new Usage   : Function: Args    : Returns :"
.IX Subsection "new Title : new Usage : Function: Args : Returns :"
.SS "import_metainfo Title   : import_metainfo Usage   : Function: Give each metagenome a unique name, link \s-1FASTA\s0 and \s-1QUAL\s0 to a new location and register that for later use Args    : Returns :"
.IX Subsection "import_metainfo Title : import_metainfo Usage : Function: Give each metagenome a unique name, link FASTA and QUAL to a new location and register that for later use Args : Returns :"
.SS "link_uncompress_file Title   : Uncompress a file to a given destination. If file is not in a compressed format, a link is done. Supports: .gz .Z .bz2 .zip Usage   : Function: Args    : Returns :"
.IX Subsection "link_uncompress_file Title : Uncompress a file to a given destination. If file is not in a compressed format, a link is done. Supports: .gz .Z .bz2 .zip Usage : Function: Args : Returns :"
.SS "import_sequences Title   : import_sequences Usage   : Function: Args    : Returns :"
.IX Subsection "import_sequences Title : import_sequences Usage : Function: Args : Returns :"
.SS "get_size_stats Title   : get_size_stats Usage   : Function: Args    : Returns :"
.IX Subsection "get_size_stats Title : get_size_stats Usage : Function: Args : Returns :"
.SS "get_rand_sample Title   : get_rand_sample Usage   : Function: Args    : Returns :"
.IX Subsection "get_rand_sample Title : get_rand_sample Usage : Function: Args : Returns :"
.SS "destroy Title   : destroy Usage   : Function: Args    : Returns :"
.IX Subsection "destroy Title : destroy Usage : Function: Args : Returns :"
.ie n .SS "rand_subset Title   : rand_subset Usage   : $subset_arrayref = $self\->rand_subset(\e@array, 10); Function: Take a given number of elements from a given array at random. It uses the Fisher-Yates algorithm to shuffle the tail of the array and returns only that shuffled tail. Args    : arrayref number of elements (integer) Returns : arrayref"
.el .SS "rand_subset Title   : rand_subset Usage   : \f(CW$subset_arrayref\fP = \f(CW$self\fP\->rand_subset(\e@array, 10); Function: Take a given number of elements from a given array at random. It uses the Fisher-Yates algorithm to shuffle the tail of the array and returns only that shuffled tail. Args    : arrayref number of elements (integer) Returns : arrayref"
.IX Subsection "rand_subset Title : rand_subset Usage : $subset_arrayref = $self->rand_subset(@array, 10); Function: Take a given number of elements from a given array at random. It uses the Fisher-Yates algorithm to shuffle the tail of the array and returns only that shuffled tail. Args : arrayref number of elements (integer) Returns : arrayref"
.ie n .SS "_trim_obj Title   : _trim_obj Usage   : $trimmed_seq = $self\->_trim($trim_l, $seq); Function: Trim a \s-1DNA\s0 sequence and quality scores to a specified length starting at random position in the sequence Args    : \- trimming length \- Bio::PrimarySeqI or Bio::SeqI sequence Returns : \- truncated Bio::PrimarySeqI or Bio::SeqI sequence"
.el .SS "_trim_obj Title   : _trim_obj Usage   : \f(CW$trimmed_seq\fP = \f(CW$self\fP\->_trim($trim_l, \f(CW$seq\fP); Function: Trim a \s-1DNA\s0 sequence and quality scores to a specified length starting at random position in the sequence Args    : \- trimming length \- Bio::PrimarySeqI or Bio::SeqI sequence Returns : \- truncated Bio::PrimarySeqI or Bio::SeqI sequence"
.IX Subsection "_trim_obj Title : _trim_obj Usage : $trimmed_seq = $self->_trim($trim_l, $seq); Function: Trim a DNA sequence and quality scores to a specified length starting at random position in the sequence Args : - trimming length - Bio::PrimarySeqI or Bio::SeqI sequence Returns : - truncated Bio::PrimarySeqI or Bio::SeqI sequence"
.ie n .SS "_trim_str Title   : _trim_str Usage   : ($trimmed_seq, $trimmed_qual) = $self\->_trim_str($trim_l, $seq_str, $qual_str); Function: Trim a \s-1DNA\s0 sequence string and quality scores arrayred to a specified length starting at random position in the sequence Args    : \- trimming length \- sequence string \- quality score arrayref Returns : \- truncated sequence string \- truncated quality score arrayref"
.el .SS "_trim_str Title   : _trim_str Usage   : ($trimmed_seq, \f(CW$trimmed_qual\fP) = \f(CW$self\fP\->_trim_str($trim_l, \f(CW$seq_str\fP, \f(CW$qual_str\fP); Function: Trim a \s-1DNA\s0 sequence string and quality scores arrayred to a specified length starting at random position in the sequence Args    : \- trimming length \- sequence string \- quality score arrayref Returns : \- truncated sequence string \- truncated quality score arrayref"
.IX Subsection "_trim_str Title : _trim_str Usage : ($trimmed_seq, $trimmed_qual) = $self->_trim_str($trim_l, $seq_str, $qual_str); Function: Trim a DNA sequence string and quality scores arrayred to a specified length starting at random position in the sequence Args : - trimming length - sequence string - quality score arrayref Returns : - truncated sequence string - truncated quality score arrayref"
.ie n .SS "_create_unique_names Title   : _create_unique_names Usage   : @names = @{$self\->_create_unique_names(\e@fastafiles)}; Function: produces unique metagenome names Args    : fasta files arrayref Returns : unique names arrayref"
.el .SS "_create_unique_names Title   : _create_unique_names Usage   : \f(CW@names\fP = @{$self\->_create_unique_names(\e@fastafiles)}; Function: produces unique metagenome names Args    : fasta files arrayref Returns : unique names arrayref"
.IX Subsection "_create_unique_names Title : _create_unique_names Usage : @names = @{$self->_create_unique_names(@fastafiles)}; Function: produces unique metagenome names Args : fasta files arrayref Returns : unique names arrayref"
.ie n .SS "_filter_low_cplx Title   : _filter_low_cplx Usage   : my @seqs = _filter_low_cplx( $seq_obj, $cplxthres, $cplxwindow ); Function: Filter out low complexity sequences by specifying a minimum dinucleotide entropy (Shannon-Wiener index h). If a sliding window length is specified, regions of low complexity are removed (instead of discarding the entire sequence), thereby splitting the sequence in several pieces. Args    : \- Bio::Seq object \- minimum entropy threshold \- sliding window length Returns : \- ranges of high complexity regions in the sequence"
.el .SS "_filter_low_cplx Title   : _filter_low_cplx Usage   : my \f(CW@seqs\fP = _filter_low_cplx( \f(CW$seq_obj\fP, \f(CW$cplxthres\fP, \f(CW$cplxwindow\fP ); Function: Filter out low complexity sequences by specifying a minimum dinucleotide entropy (Shannon-Wiener index h). If a sliding window length is specified, regions of low complexity are removed (instead of discarding the entire sequence), thereby splitting the sequence in several pieces. Args    : \- Bio::Seq object \- minimum entropy threshold \- sliding window length Returns : \- ranges of high complexity regions in the sequence"
.IX Subsection "_filter_low_cplx Title : _filter_low_cplx Usage : my @seqs = _filter_low_cplx( $seq_obj, $cplxthres, $cplxwindow ); Function: Filter out low complexity sequences by specifying a minimum dinucleotide entropy (Shannon-Wiener index h). If a sliding window length is specified, regions of low complexity are removed (instead of discarding the entire sequence), thereby splitting the sequence in several pieces. Args : - Bio::Seq object - minimum entropy threshold - sliding window length Returns : - ranges of high complexity regions in the sequence"
.ie n .SS "_dinucleotide_entropy Title   : _dinucleotide_entropy Usage   : ($H, $dn_counts, $nof_dinucs) = $self\->_dinucleotide_entropy($seqstr, $start_pos, $window, $prev_H, $prev_dn_counts, $prev_nof_dinucs) Function: Calculate the entropy (Shannon index) of the dinucleotides in a sequence fragment Args    : Returns :"
.el .SS "_dinucleotide_entropy Title   : _dinucleotide_entropy Usage   : ($H, \f(CW$dn_counts\fP, \f(CW$nof_dinucs\fP) = \f(CW$self\fP\->_dinucleotide_entropy($seqstr, \f(CW$start_pos\fP, \f(CW$window\fP, \f(CW$prev_H\fP, \f(CW$prev_dn_counts\fP, \f(CW$prev_nof_dinucs\fP) Function: Calculate the entropy (Shannon index) of the dinucleotides in a sequence fragment Args    : Returns :"
.IX Subsection "_dinucleotide_entropy Title : _dinucleotide_entropy Usage : ($H, $dn_counts, $nof_dinucs) = $self->_dinucleotide_entropy($seqstr, $start_pos, $window, $prev_H, $prev_dn_counts, $prev_nof_dinucs) Function: Calculate the entropy (Shannon index) of the dinucleotides in a sequence fragment Args : Returns :"
.ie n .SS "_valid_dinucleotide Title   : _valid_dinucleotide Usage   : $is_valid = $self\->_dinucleotide_entropy($dinuc, $dinuc_hashref) Function: Check if a dinucleotide is a valid sequence (containing only 'A's, 'C's, 'G's and 'T's Args    : \- dinucleotide to test \- hashref of all valid dinucleotides Returns : 1 (valid) or 0 (not valid)"
.el .SS "_valid_dinucleotide Title   : _valid_dinucleotide Usage   : \f(CW$is_valid\fP = \f(CW$self\fP\->_dinucleotide_entropy($dinuc, \f(CW$dinuc_hashref\fP) Function: Check if a dinucleotide is a valid sequence (containing only 'A's, 'C's, 'G's and 'T's Args    : \- dinucleotide to test \- hashref of all valid dinucleotides Returns : 1 (valid) or 0 (not valid)"
.IX Subsection "_valid_dinucleotide Title : _valid_dinucleotide Usage : $is_valid = $self->_dinucleotide_entropy($dinuc, $dinuc_hashref) Function: Check if a dinucleotide is a valid sequence (containing only 'A's, 'C's, 'G's and 'T's Args : - dinucleotide to test - hashref of all valid dinucleotides Returns : 1 (valid) or 0 (not valid)"
